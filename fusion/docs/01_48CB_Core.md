# Module 01: 48-Control Bench Core Engine (48CB-Core)

## 1. Rationale & Purpose

This directory contains the source code and documentation for the core algorithmic engine of the 48-Control Bench. This is the "brain" of the MVP. Its purpose is to implement the foundational principles of the 48-manifold framework as a reusable, domain-agnostic Python library.

The central thesis is that instability in complex systems (like fusion plasmas) can be managed more effectively by a control system that is **reversible, symmetric, and measurement-first by construction.** This engine is designed to prove that such a controller can be built and that it outperforms conventional methods by avoiding "unforced errors" like aliasing, controller thrash, and irreversible commitments.

This module is the most critical component. Its success is defined by its ability to translate raw, noisy time-series data into clean, canonical, and actionable control decisions according to the principles of combinatorial game theory (Conway's ONAG).

## 2. Core Components & Architecture

The engine is built as a modular pipeline in Python, using JAX for hardware acceleration and automatic differentiation where needed.

### 2.1. `MeasurementFirst` Pipeline
- **Purpose:** To ingest raw diagnostic signals and produce a clean, provenance-tracked state vector without information loss.
- **Implementation:**
    - A registry of "forward models," one for each diagnostic channel. These are simple physics-based or data-driven models that map raw signals to physical quantities.
    - A single, guard-banded resampling step to bring all signals to a common time base on the 48-phase clock. This is the **only** resampling allowed in the entire pipeline.
    - All outputs are tagged with PROV-O compliant lineage, tracing them back to the raw signals and the specific version of the forward model used. This enforces the **anti-decimation** discipline.

### 2.2. `GameEncoder`
- **Purpose:** To translate the cleaned physical state vector into a formal game `G = {L | R}`.
- **Implementation:**
    - **`Right` Options (Hot/Instability):** These are generated from instability predictors (e.g., NTM growth rate predictors, disruption risk estimators). Each `Right` option represents a predicted future "move" by the plasma.
    - **`Left` Options (Cold/Stabilizing):** These are generated by sampling the available actuator space (e.g., small, reversible changes in RMP coil phasing, ECCD deposition location). Each `Left` option represents a potential stabilizing "move" for the controller.

### 2.3. `Canonicalizer`
- **Purpose:** To prune the raw game `G` to its minimal, essential strategic kernel, `Gk`. This is the formal implementation of the `kull` operator.
- **Implementation:**
    - Implements the two core rules from Conway's ONAG:
        1. **Remove Dominated Options:** For any two `Left` options L1 and L2, if L1 is provably better than L2 under all of `Right`'s responses, L2 is removed.
        2. **Bypass Reversible Moves:** If a `Left` move can be immediately undone by a `Right` response that leads to a simpler state, that move is bypassed.
    - **Decomposition:** Computes the `mean` (the cold, baseline value of the game) and the `temperature` (the hot, residual risk or uncertainty). The **temperature** is the primary control signal for the system.

### 2.4. `Phase48_Scheduler`
- **Purpose:** To map abstract control actions onto a concrete, symmetric, and reversible 48-phase actuation lattice.
- **Implementation:**
    - Uses the Chinese Remainder Theorem (`CRT(16, 3)`) to provide a unique, invertible mapping from a linear index (0-47) to a spatial or temporal coordinate.
    - Actuator commands are scheduled into these 48 slots to ensure symmetric application and avoid exciting unwanted plasma modes.
    - All actions are defined as small, reversible permutations (e.g., a slight phase rotation) that can be cleanly undone if the system's "temperature" rises.

### 2.5. `ControlSynthesizer`
- **Purpose:** To select and execute the optimal line of play.
- **Implementation:**
    - **Primary Policy:** At each time step, select the available `Left` move that produces the greatest predicted **reduction in game temperature**. This is the "cooling line of play."
    - **Cadence:** Executes a `Left → Right (observe) → Left` cadence, constantly seeking to cool the game state towards a stable `stop` (zero temperature).

## 3. Technical Specifications
- **Language:** Python 3.10+
- **Core Libraries:** JAX, NumPy, Pandas (for data handling), `prodict` (for provenance).
- **Interfaces:**
    - **Input:** Expects time-series data in a standardized format (e.g., Parquet files with schema).
    - **Output:** Produces a time-series of actuator set-points and a detailed log of the internal game state (including temperature) at each step.
- **Testing:** Comprehensive unit tests for each component and integration tests for the full pipeline.

## 4. Success Criteria
- The engine can process a 10-channel, 1kHz time-series faster than real-time on a single GPU.
- The `Canonicalizer` can reduce a game with ~100 raw options to a kernel of <5 options in under 1ms.
- The `temperature` output must be a more sensitive and reliable predictor of instability onset than any single input signal, as measured by AUC on the benchmark datasets.
- The generated control sequences must be verifiably symmetric and reversible.
